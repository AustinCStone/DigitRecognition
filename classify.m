function [classificationVector, percentCorrect ] = classify(eigenVectorsMat, meanImage, digitToProjections, testImages, testLabels, numNeighbors)
%takes the map from digit to eigenprojections generated by
%getDigitClassProjections, and runs through each entry in the map.
%Classifies based on the class of the "numNeighbors" nearest neighbors.

%NOTE: Since there isn't a priority queue native to Matlab or an easy way
%to implement one, I look at the "numNeighbors" nearest neighbors per
%digit, and a compare the sum of these similarities to that of the other
%digits. 


rows = 28;
cols = 28;
comparisonsPerDigit = 50;
classificationVector = zeros(1,size(testImages,4));
percentCorrect = 0;


for trial=1:size(testImages,4)
    testDigit = testLabels(trial);
    %get testDigitVec
    testDigitVec = reshape(testImages(:,:,:,trial), rows*cols, 1);
    %normalize
    testDigitVec = testDigitVec./norm(testDigitVec);
    %mean center
    testDigitVec = testDigitVec-meanImage;
    %project onto eignvectors
    testDigitEigenProj = (testDigitVec'*eigenVectorsMat)';
    
    import MinHeap;
    
    %use a max heap to store the "numNeighbors" nearest neighbors
    minHeap = MinHeap(numNeighbors);
    
    
      
    
    
    cumulativeDigitSimilarity=collections.map({0,1,2,3,4,5,6,7,8,9},{0,0,0,0,0,0,0,0,0,0});
    
    
    for digit=0:9
        
        %go though all projections onto the eigenvectors and determine the
        %distance
        digitProjections = digitToProjections(digit);
        for i=1:comparisonsPerDigit
            trainEigenProjection = digitProjections(:,i);
            cosineSimilarity = trainEigenProjection'*testDigitEigenProjection;
            if (minHeap.count()<numNeighbors)
                minHeap.InsertKey(cosineSimilarity);
            elseif (minHeap.ReturnMin()<cosineSimilarity)
                minHeap.ExtractMin();
                minHeap.InsertKey(cosineSimilarity);
            end
            
            
        end
        
        cumulativeDigitSimilarity(digit)=sum(minHeap.sort()); %sort returns a vector of the elements 
        minHeap.Clear();
        
    end
    
    bestSimilarity=0;
    bestDigit = 0;
    for digit=0:9
        if (cumulativeDigitSimilarity(digit)>bestSimilarity)
            bestSimilarity = cumulativeDigitSimilarity(digit);
            bestDigit = digit;
        end
            
    end
    
    if(bestDigit == testDigit)
        disp('yay, correct!!');
        percentCorrect = percentCorrect+1;
    else
        disp('no, wrong!!');
    end
    
    classificationVector(trial)=bestDigit;
end
    
percentCorrect=percentCorrect/size(testImages,4);


end

